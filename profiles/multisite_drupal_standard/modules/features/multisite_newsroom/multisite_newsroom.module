<?php
/**
 * @file
 * Code for the Multisite Newsroom feature.
 */


include_once 'multisite_newsroom.features.field_base.inc';
include_once 'multisite_newsroom.features.inc';

/**
 * Implements hook_menu().
 */
function multisite_newsroom_menu() {
  // Configuration page.
  $items['admin/config/content/newsroom'] = array(
    'title' => 'Newsroom',
    'description' => 'Configure Newsroom settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('multisite_newsroom_admin_settings'),
    'access arguments' => array('administer newsroom settings'),
    'file' => 'multisite_newsroom.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_help().
 */
function multisite_newsroom_help($path, $arg) {
  $help = '';
  switch ($path) {
    // Help text for the newsroom feature.
    case 'admin/help#multisite_newsroom':
      $help = '<p>' . t('The multisite newsroom feature is meant to integrate the newsroom corporate service into a Drupal Multisite/Next Europa client. By enabling it you will have the chance to fetch contents from the newsroom service basing on the configuraiton of your "universe" into your instance of the newsroom. To configure the newsroom you will need to get an "Universe id" from the service provider, you will have this code once your universe has been fully configured as a service and it will be ready to serve you contents. In the newsroom <a href="@newsroom" title="newsroom configuraiton">admin settings page</a> you can then define many of the newsroom behaviours and you can start palying associating you existing content types with the newly imported news coming from the newsroom.', array('@newsroom' => url('admin/config/content/newsroom'))) . '</p>';

    break;
  }

  return $help;
}

/**
 * Implements hook_permission().
 */
function multisite_newsroom_permission() {
  return array(
    'administer newsroom settings' => array(
      'title' => t('Administer Newsroom settings'),
    ),
    'administer newsroom advanced settings' => array(
      'title' => t('Administer all the newsroom settings'),
    ),
  );
}

/**
 * Sets feature set api version.
 *
 * @return array
 *   version number
 */
function multisite_newsroom_feature_set_api() {
  return array('version' => '1.0');
}

/**
 * Implements hook_image_default_styles().
 */
function multisite_newsroom_image_default_styles() {
  $styles = array();

  // Exported image style: newsroom_style.
  $styles['newsroom_style'] = array(
    'name' => 'newsroom_style',
    'label' => 'newsroom_style',
    'effects' => array(
      1 => array(
        'label' => 'Scale',
        'help' => 'Scaling will maintain the aspect-ratio of the original image. If only a single dimension is specified, the other dimension will be calculated.',
        'effect callback' => 'image_scale_effect',
        'dimensions callback' => 'image_scale_dimensions',
        'form callback' => 'image_scale_form',
        'summary theme' => 'image_scale_summary',
        'module' => 'image',
        'name' => 'image_scale',
        'data' => array(
          'width' => 250,
          'height' => '',
          'upscale' => 1,
        ),
        'weight' => 1,
      ),
    ),
  );

  return $styles;
}

/**
 * Implements hook_post_features_enable_feature().
 */
function multisite_newsroom_post_features_enable_feature($component) {
  if ($component == 'field_base') {
    // Revert the field component, it seems it is not ready after it's enabled.
    features_revert(array('multisite_newsroom' => array($component)));
  }
}

/**
 * Implements hook_post_features_revert().
 */
function multisite_newsroom_post_features_revert($component) {
  _multisite_newsroom_create_instances($component);
}

/**
 * Helper function to create "fake" isntances of exported field bases.
 *
 * @param string $component
 *   Feature component name.
 */
function _multisite_newsroom_create_instances($component) {
  // Create a content type if it doesn't exist already.
  if ($component != 'field_base') {
    return;
  }
  else {
    $type_name = 'multisite_newsroom_fs';
    $type = node_type_load($type_name);
    if (!$type) {
      $type = array(
        'type' => $type_name,
        'name' => t('Field instances'),
        'base' => 'node_content',
        'description' => t('Instantiate fields'),
        'custom' => 1,
        'modified' => 1,
        'locked' => 0,
        'disabled' => 1,
      );

      $type = node_type_set_defaults($type);
      node_type_save($type);
    }

    // Get fields from the features file.
    $fields = call_user_func_array('multisite_newsroom_field_default_field_bases', array(''));

    // Loop through the fields and build "fake" instances.
    foreach ($fields as $field_name => $field_options) {
      $exist = field_info_instance('node', $field_name, $type->type);
      // Only work with unlocked fields and check for existing instances.
      if ($field_options['locked'] == 0 && $exist === NULL) {
        $instance = array(
          'field_name' => $field_name,
          'entity_type' => 'node',
          'bundle' => $type->type,
          'label' => 'default instance',
          'description' => 'A default instance',
          'required' => 0,
        );
        field_create_instance($instance);
      }
    }
  }
}

/**
 * Helper function to check if the universe ID has been already set.
 */
function _multisite_newsroom_check_universe_id() {
  // After initital setup disable Universe ID field.
  $universe_id = array();
  if (variable_get('newsroom_universe_id', NULL) !== NULL) {
    $universe_id['disabled'] = TRUE;
    $universe_id['description'] = t('To change the Newsroom Universe ID contact the site administrator.');
    $universe_id['class'] = "selected";
    $universe_id['collapsing'] = FALSE;
  }
  else {
    $universe_id['disabled'] = FALSE;
    $universe_id['description'] = t('After setting the Newsroom Universe ID for the first time content will be imported from the Newsroom service. This might take a few minutes.');
    $universe_id['class'] = "not-selected";
    $universe_id['collapsing'] = TRUE;
  }
  return $universe_id;
}

/**
 * Prepare options for the content type select.
 *
 * @param string $type
 *   Type of the options to generate.
 *
 * @return array
 *   Array of options.
 */
function _multisite_newsroom_prepare_options($type) {
  $options = array();
  if (is_numeric($type)) {
    for ($i = 1; $i <= $type; $i++) {
      $options[$i] = $i;
    }
  }
  else {
    // Get a list of the existing content type.
    $content_types = node_type_get_types();
    // Exclude the ct used for the import.
    unset($content_types['newsroom_item']);
    unset($content_types['newsroom_selection']);
    // Build options for selecting content types.
    foreach ($content_types as $name => $content_type) {
      if ($content_type->disabled !== 1) {
        $options[$name] = $content_type->name;
      }
    }
  }
  return $options;
}

/**
 * Add fields to selected content types.
 *
 * @param string $type
 *   Select or topic fo the moment.
 * @param array $sel_ct
 *   Array of content types machine names.
 */
function _multisite_newsroom_add_fields($type = 'topic', $sel_ct = array()) {
  $field_name = 'field_associated_newsroom_' . $type;

  if (!empty($sel_ct)) {
    foreach ($sel_ct as $machine_name => $content_type) {
      $exist = field_info_instance('node', $field_name, $machine_name);
      // Check for existing instances.
      if ($exist === NULL) {
        $instance = array(
          'field_name' => $field_name,
          'entity_type' => 'node',
          'bundle' => $machine_name,
          'label' => 'Newsroom ' . $type,
          'description' => '',
          'required' => 0,
        );
        field_create_instance($instance);
        // Call the field_group helper function, we surely have to update it.
        _multisite_newsroom_field_group($machine_name, $field_name);
        // Set a message to inform the user about the field instance creation.
        drupal_set_message(t('Created instance of @field in the @bundle content type', array('@field' => $field_name, '@bundle' => $machine_name)));
      }
    }
  }
}

/**
 * Remove all the instances of a fields.
 *
 * @param string $type
 *   Select or topic fo the moment.
 * @param array $sel_ct
 *   Array of content types machine names.
 */
function _multisite_newsroom_remove_fields($type = 'topic', $sel_ct = array()) {
  // This function runs after checking for existing field values in the databas.
  $field_name = 'field_associated_newsroom_' . $type;
  // All is the parameter we get when an user want to delete all the instances.
  if ($sel_ct == 'all') {
    $instances = _multisite_newsroom_get_instances($type);
  }
  // Limit the search to the selected content types.
  elseif (!empty($sel_ct)) {
    foreach ($sel_ct as $content_type) {
      $instances[] = $content_type;
    }
  }

  if (!empty($instances)) {
    // Loop through the instances to delete them.
    foreach ($instances as $instance) {
      $instance = field_info_instance('node', $field_name, $instance);
      field_delete_instance($instance, FALSE);
      // Call the field_group helper function, we could have to delete it.
      _multisite_newsroom_field_group($instance['bundle'], $field_name);
      // Add the message to queue.
      drupal_set_message(t('Deleted instance of @field in the @bundle content type', array('@field' => $field_name, '@bundle' => $instance['bundle'])));
    }
  }
}

/**
 * Get the existing instances of fields.
 *
 * @param string $type
 *   Select or topic for the moment.
 *
 * @return array
 *   instances
 */
function _multisite_newsroom_get_instances($type) {
  // Get instances per field.
  $instances = array();
  if ($type) {
    $content_types = node_type_get_types();
    $field_name = 'field_associated_newsroom_' . $type;
    $instances = array();
    // We loop through the list of content types to find all the instances.
    foreach ($content_types as $machine_name => $content_type) {
      $exist = field_info_instance('node', $field_name, $machine_name);
      if ($exist !== NULL) {
        $instances[] = $exist['bundle'];
      }
    }
  }
  return $instances;
}

/**
 * Check if it safe to delete field instances.
 *
 * @param string $type
 *   Select or topic fo the moment.
 * @param array $checks
 *   Array of items to check.
 *
 * @return array
 *   Information about the field name and nodes found.
 */
function _multisite_newsroom_check_deletion($type, $checks = array()) {
  $nodes = array();
  // "All" is the parameter we get to delete all the instances.
  if ($checks == 'all') {
    $instances = _multisite_newsroom_get_instances($type);
  }
  else {
    if (!empty($checks)) {
      // Get the instances to check for.
      foreach ($checks as $field => $check) {
        $instances[] = $check;
      }
    }
  }

  if (!empty($instances)) {
    foreach ($instances as $instance) {
      // Check in the database for values of the selected field.
      $query = db_select('field_data_field_associated_newsroom_' . $type, 'ch');
      $query->condition('bundle', $instance, '=');
      $num_rows = $query->countQuery()->execute()->fetchField();
      // There are values, we store the number of nodes to show it to the user.
      if ($num_rows > 0) {
        $nodes['field_data_field_associated_newsroom_' . $type][] = array(
          'ct' => $instance,
          'nodes' => $num_rows,
        );
      }
    }
  }
  return $nodes;
}

/**
 * Prepare check for instances deletion.
 *
 * @param array $previous
 *   Old values.
 * @param array $input
 *   New values.
 *
 * @return array
 *   Variables to pass.
 */
function _multisite_newsroom_prepare_check($previous, $input) {
  // Set some values.
  $selected['topic'] = array_filter($input['newsroom_content_types_topic']);
  $selected['select'] = array_filter($input['newsroom_content_types_select']);
  $check_topic = array();
  $check_select = array();
  // Check the two array for differences. we need to catch also a deselection.
  if ($selected != $previous) {
    $check_topic[] = array_diff($previous['topic'], $selected['topic']);
    $check_topic[] = array_diff($selected['topic'], $previous['topic']);
    $check_select[] = array_diff($previous['select'], $selected['select']);
    $check_select[] = array_diff($selected['select'], $previous['select']);
  }
  // Prepare all the relevant data formatted into an array().
  $infos = array(
    'selected' => array(
      'topic' => $selected['topic'],
      'select' => $selected['select'],
    ),
    'delete' => array(
      'topic' => $input['newsroom_content_types_delete_topic'],
      'select' => $input['newsroom_content_types_delete_select'],
    ),
    'check' => array(
      'topic' => $check_topic,
      'select' => $check_select,
    ),
  );

  return $infos;
}

/**
 * Create a field_group to hold the newsroom fields in a vertical tab.
 *
 * @param string $machine_name
 *   Content type machine name.
 * @param string $field_name
 *   Field machine name.
 */
function _multisite_newsroom_field_group($machine_name, $field_name) {
  // Get info about the group, it's likely to be already in the database.
  $groups = field_group_info_groups('node', $machine_name, 'form', TRUE);
  $fields = array('topic', 'select');
  $group_name = 'group_' . $machine_name . '_newsroom';
  $instances = FALSE;
  // Check for instances of the newsroom fields inside the given content type.
  foreach ($fields as $field) {
    $field_name = 'field_associated_newsroom_' . $field;
    if (field_info_instance('node', $field_name, $machine_name) != NULL) {
      $instances[] = field_info_instance('node', $field_name, $machine_name);
    }
  }
  // If the group is already there, remove it.
  if (isset($groups[$group_name])) {
    $query = db_delete('field_group')
      ->condition('bundle', $machine_name, '=')
      ->condition('group_name', 'group_' . $machine_name . '_newsroom', '=')
      ->execute();
  }
  // Create the group with the right children.
  if ($instances) {
    $field_group = (object) array(
      'identifier' => $group_name . '|node|' . $machine_name . '|form',
      'group_name' => $group_name,
      'entity_type' => 'node',
      'bundle' => $machine_name,
      'mode' => 'form',
      'children' => array(),
      'parent_name' => '',
      'weight' => 5,
      'label' => 'Newsroom fields',
      'format_type' => 'tab',
      'disabled' => FALSE,
      'format_settings' => array(
        'instance_settings' => array(
          'required_fields' => 0,
          'classes' => 'group-newsroom field-group-tab',
          'description' => '',
        ),
        'formatter' => 'closed',
      ),
    );

    foreach ($instances as $instance) {
      $field_group->children[] = $instance['field_name'];
    }

    field_group_group_save($field_group);
  }
  // Remove the group since we don't have fields to show.
  else {
    drupal_set_message(t('Removed the fieldgroup @name from the @content_type content type', array('@name' => $group_name, '@content_type' => $machine_name)), 'status');
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function multisite_newsroom_form_multisite_newsroom_admin_settings_alter(&$form, &$form_state, $form_id) {
  // If we are in a confimation step, change the form visualization.
  if (isset($form_state['storage']['confirm'])) {
    drupal_set_message(t('You are in a confirmation page, to submit all the form settings check the box below'), 'warning');
    $form['newsroom_universe']['#collapsible'] = TRUE;
    $form['newsroom_universe']['#collapsed'] = TRUE;
    $form['newsroom_fields']['#collapsed'] = FALSE;
  }
}

/**
 * Submit handler.
 */
function multisite_newsroom_restore_conf($form, &$form_state) {
  $voc = $form['vocabulary_machine_name']['#value'];
  // Get the id coming from the newsroom.
  $id = _multisite_newsroom_get_ids($voc, $form['#term']);
  // The name of the variable contains the id.
  $name = $voc . '_backup';
  $backup = variable_get($name, array());

  if (empty($backup)) {
    drupal_set_message(t('No backup has been found for the vocabulary: @voc and the term: @name.', array('@voc' => $voc, '@name' => $form['#term']['name'])), 'warning');
    return;
  }

  $term = $backup[$id];

  if (empty($term)) {
    drupal_set_message(t('No backup has been found for the term: @name.', array('@name' => $form['#term']['name'])), 'warning');
    return;
  }

  // Override values basing on the backup ones.
  foreach ($term as $propname => $prop) {
    $form_state['values'][$propname]['und'][0]['value'] = $prop;
  }

  // Set a message for the user.
  drupal_set_message(t('The configuration for the term "@name" has been restored from the backup version.', array('@name' => $form['#term']['name'])), 'status');
  // Submit the form so the term get saved.
  return taxonomy_form_term_submit($form, $form_state);
}

/**
 * Submit handler.
 */
function multisite_newsroom_restore_conf_all($form, &$form_state) {
  $name = '';
  $voc = $form['#vocabulary']->machine_name;
  // Get the current variable for the specific vocubulary,
  $backup = variable_get($voc . '_backup', array());

  if (!empty($backup)) {
    // Divide terms into chunks, grouping five of them.
    $chunks = array_chunk($backup, 5, TRUE);
    $num_operations = $sandbox['limit'] = count($chunks);
    $operations = array();

    for ($i = 0; $i < $num_operations; $i++) {
      $operations[] = array(
        'multisite_newsroom_restore_batch',
        array(
          $chunks[$i],
          $voc,
          t('(Operation @operation)', array('@operation' => $i)),
        ),
      );
    }

    $batch = array(
      'operations' => $operations,
      'finished' => 'multisite_newsroom_restore_batch_finished',
      'title' => t('Restore configuration for terms'),
      'init_message' => t('The restore of your configuration has been started'),
      'progress_message' => t('Current: @current | Remaining:
        @remaining | Total: @total | Percentage: @percentage | Estimate:
        @estimate | Elapsed: @elapsed'),
      'error_message' => t('The restore did not work.'),
    );

    batch_set($batch);
  }
  else {
    drupal_set_message(t("We couldn't get the backup for the vocabulary: @voc", array('@voc' => $voc)), 'warning');
  }
}

/**
 * The batch operation.
 *
 * @param array $chunk
 *   The terms to be updated.
 * @param string $voc
 *   Vocabulary's machine name.
 * @param array $operation_details
 *   Array of values.
 */
function multisite_newsroom_restore_batch($chunk, $voc, $operation_details) {

  foreach ($chunk as $id => $fields) {
    // Try to find the corresponding term basing on its ID.
    $term = _multisite_newsroom_get_term_from_id($id, $voc);
    if ($term) {
      // Let's work with an array.
      $term = get_object_vars($term);

      // This is special, make them handable!.
      $special = array(
        'field_newsroom_field_featured_item'
      );

      if (!empty($fields)) {
        // Override values
        foreach ($fields as $field_name => $value) {
          if (!in_array($propname, $special)) {
            $term[$field_name]['und'][0]['value'] = $value;
          }
          else {
            if (is_numeric($value)) {
              $term[$field_name]['und'][0]['target_id'] = $value;
            }
            else {
              unset($term[$field_name]['und'][0]);
            }
          }
        }

        if (isset($context)) {
          // Build the worked term name list.
          $context['results'][] .= $conf['name'] . ', ';
          $context['message'] = t('Restoring "@title"', array('@title' => $term['name'])) . ' ' . $operation_details;
        }
      }
      // Save the term with the new values.
      taxonomy_term_save((object) $term);
    }
  }
}

/**
 * Submit handler.
 */
function multisite_newsroom_backup_conf($form, &$form_state) {
  $voc = $form['vocabulary_machine_name']['#value'];
  $tree = taxonomy_get_tree($voc);
  // Get the current backup.
  $current_values = variable_get($voc . '_backup', array());
  $id = _multisite_newsroom_get_ids($voc, $form_state['values']);
  $term = (object) $form_state['values'];
  $new_values = _multisite_newsroom_export_prepare_values($term);
  // If no backup have been saved, save it for for the first time.
  if (empty($current_values)) {
    variable_set($voc . '_backup', $new_values);
  }
  else {
    // Override the values for the specific term.
    $new_values = reset($new_values);
    $current_values[$id] = $new_values;
  }

  // Set values for the newsroom backup.
  variable_set($voc . '_backup', $current_values);

  // Set a message to the user.
  drupal_set_message(t('We saved a backup of your configuration for the term "@name". if you need to restore the values in the backup click on the "Restore & Save" button', array('@name' => $form['#term']['name'])), 'status');
  // Submit the form so the term get saved.
  return taxonomy_form_term_submit($form, $form_state);
}

/**
 * Submit handler.
 */
function multisite_newsroom_backup_conf_all($form, &$form_state) {
  $name = '';
  $voc = $form['#vocabulary']->machine_name;
  // We need the whole tree here.
  $tree = taxonomy_get_tree($form['#vocabulary']->vid);

  foreach ($tree as $base_term) {
    $tid = $base_term->tid;
    $term = taxonomy_term_load($tid);
    $id = _multisite_newsroom_get_ids($voc, (array) $term);

    // Working with arrays.
    $term = _multisite_newsroom_export_prepare_values($term);
    $term = reset($term);
    $values[$id] = $term;
  }

  // Save the variable.
  variable_set($voc . '_backup', $values);

  // Set a message to the user.
  drupal_set_message(t('We saved a backup of your configuration for the vocabulary: "@name". if you need to restore the values in the backup click on the "Restore" button', array('@name' => $voc)), 'status');
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function multisite_newsroom_form_taxonomy_form_term_alter(&$form, &$form_state) {
  $voc_name = $form['vocabulary_machine_name']['#value'];

  switch ($voc_name) {
    case 'newsroom_item_type':
    case 'newsroom_service':
    case 'newsroom_topic':

      $form['actions']['restore_config'] = array(
        '#type' => 'submit',
        '#value' => t('Restore conf & Save'),
        '#submit' => array('multisite_newsroom_restore_conf'),
      );

      $form['actions']['backup_config'] = array(
        '#type' => 'submit',
        '#value' => t('Backup conf & Save'),
        '#submit' => array('multisite_newsroom_backup_conf'),
      );

    break;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function multisite_newsroom_form_taxonomy_overview_terms_alter(&$form, &$form_state) {
  $vocs = array(
    'newsroom_topic',
    'newsroom_service',
    'newsroom_item_type',
  );

  if (in_array($form['#vocabulary']->machine_name, $vocs)) {
    $form['actions']['backup_config'] = array(
      '#type' => 'submit',
      '#value' => t('Backup configuration'),
      '#submit' => array('multisite_newsroom_backup_conf_all'),
    );

    $form['actions']['restore_config'] = array(
      '#type' => 'submit',
      '#value' => t('Restore configuration'),
      '#submit' => array('multisite_newsroom_restore_conf_all'),
    );
  }
}

/**
 * Get newsroom id values.
 */
function _multisite_newsroom_get_ids($voc, $data) {
  switch ($voc) {
    case 'newsroom_item_type':
      $id = $data['field_newsroom_type_id']['und'][0]['value'];
      break;

    case 'newsroom_service':
      $id = $data['field_newsroom_service_id']['und'][0]['value'];
      break;

    case 'newsroom_topic':
      $id = $data['field_newsroom_topic_id']['und'][0]['value'];
      break;
  }
  return $id;
}

/**
 * Grab the newsroom fields from a term.
 *
 * @param object $term
 *  The term to get the values from.
 * @return array
 *  Formatted values for the newsroom related fields.
 */
function _multisite_newsroom_export_prepare_values($term) {
  $term = get_object_vars($term);
  $voc = $term['vocabulary_machine_name'];
  $id = _multisite_newsroom_get_ids($voc, $term);
  $values = array();
  $values[$id] = array();
  $voc = str_replace('_item', '', $voc);
  foreach ($term as $propname => $prop) {
    // Should work only with custom fields.
    if (strpos($propname, 'field') === 0) {
      if ($propname == 'field_' . $voc . '_id') {
        continue;
      }

      if (isset($prop['und'][0]['value'])) {
        $values[$id][$propname] = $prop['und'][0]['value'];
      }
    }
  }

  return $values;
}

/**
 * Find a term basing on its newsroom id.
 *
 * @param string $id
 *  The id coming from the newsroom.
 * @param string $voc
 *  Vocabulay's machine name.
 *
 * @return object
 *   The term object.
 */
function _multisite_newsroom_get_term_from_id($id, $voc) {
  $field = str_replace('_item', '', $voc);
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', $voc)
    ->fieldCondition('field_' . $field . '_id', 'value', $id, '=');

  $results = $query->execute();

  if (!empty($results)) {
    $result = reset($results['taxonomy_term']);
    $tid = $result->tid;
    $term = taxonomy_term_load($tid);
  }
  else {
    $term = FALSE;
  }
  return $term;
}
