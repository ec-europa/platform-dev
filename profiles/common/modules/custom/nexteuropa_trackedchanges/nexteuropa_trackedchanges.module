<?php
/**
 * @file
 * Code for the NextEuropa Tracked Changes feature.
 */

include_once 'nexteuropa_trackedchanges.admin.inc';
include_once 'nexteuropa_trackedchanges.tracking.inc';
include_once 'nexteuropa_trackedchanges.page.inc';

define('NEXTEUROPA_TRACKEDCHANGES_FHT_MACHINE_NAME', 'full_html_track');
define('NEXTEUROPA_TRACKEDCHANGES_FHT_HUMAN_NAME', 'Full HTML + Change tracking');

/**
 * Implements hook_menu().
 */
function nexteuropa_trackedchanges_menu() {
  $items['admin/config/content/wysiwyg/tracked_changes'] = [
    'title' => 'WYSIWYG tracked changes',
    'description' => 'Setup pages for "WYSIWYG tracked changes" feature',
    'position' => 'right',
    'weight' => -5,
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer ckeditor_lite'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  ];

  $items['admin/config/content/wysiwyg/tracked_changes/setup'] = array(
    'title' => 'Tracked changes buttons settings',
    'description' => 'Setup page for "WYSIWYG tracked changes" related buttons',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nexteuropa_trackedchanges_settings_form'),
    'access arguments' => array('administer ckeditor_lite'),
    'file' => 'nexteuropa_trackedchanges.admin.inc',
    'weight' => 0,
  );

  $items['admin/config/content/wysiwyg/tracked_changes/%/enable'] = array(
    'title' => 'Enable tracked changes for profile',
    'page callback' => '_nexteuropa_trackedchanges_wysiwyg_tracking_settings_enable',
    'page arguments' => array(5),
    'access arguments' => array('administer ckeditor_lite'),
    'file' => 'nexteuropa_trackedchanges.admin.inc',
  );

  $items['admin/config/content/wysiwyg/tracked_changes/%/disable'] = array(
    'title' => 'Enable tracked changes for profile',
    'page callback' => '_nexteuropa_trackedchanges_wysiwyg_tracking_settings_disable',
    'page arguments' => array(5),
    'access arguments' => array('administer ckeditor_lite'),
    'file' => 'nexteuropa_trackedchanges.admin.inc',
  );

  $items['admin/config/content/wysiwyg/tracked_changes/workbench'] = array(
    'title' => 'Tracked changes workflow settings',
    'description' => 'Setup page for the workflow controls on "WYSIWYG tracked changes" related buttons',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nexteuropa_trackedchanges_wysiwyg_tracking_settings_form'),
    'access arguments' => array('administer ckeditor_lite'),
    'file' => 'nexteuropa_trackedchanges.admin.inc',
    'weight' => 1,
  );

  $items['admin/content/tracked_changes/entities_list'] = array(
    'title' => 'Tracked changes overview',
    'description' => 'List of entities having tracked changes in their 
    WYSIWYG fields.',
    'page callback' => 'nexteuropa_trackedchanges_list',
    'access callback' => 'nexteuropa_trackedchanges_info_access',
    'file' => 'nexteuropa_trackedchanges.page.inc',
    'weight' => 10,
  );

  $items['admin/content/tracked_changes/table_rebuild'] = array(
    'title' => 'Rebuild of the table',
    'description' => 'Rebuild of the table listing all entities where tracked 
     changes have been detected',
    'page callback' => 'nexteuropa_trackedchanges_table_rebuilt',
    'access callback' => 'nexteuropa_trackedchanges_info_access',
    'file' => 'nexteuropa_trackedchanges.page.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_entity_info().
 */
function nexteuropa_trackedchanges_entity_info() {
  $info = array();

  $info['nexteuropa_trackedchanges_info'] = array(
    'label' => 'Tracked changes info',
    'entity class' => 'NextEuropaTrackedChangesInfo',
    'controller class' => 'NextEuropaTrackedChangesInfoController',
    'views controller class' => 'EntityDefaultViewsController',
    'base table' => 'nexteuropa_trackedchanges_info',
    'uri callback' => 'entity_class_uri',
    'label callback' => 'entity_class_label',
    'access callback' => 'nexteuropa_trackedchanges_info_access',
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'info_id',
    ),
    'module' => 'nexteuropa_trackedchanges',
  );

  return $info;
}

/**
 * Implements hook_entity_property_info_alter().
 */
function nexteuropa_trackedchanges_entity_property_info_alter(&$info) {
  $info['nexteuropa_trackedchanges_info']['properties']['info_id'] = array(
    'label' => t('Info id'),
    'description' => t('Id of nexteuropa_trackedchanges_info entity'),
    'type' => 'integer',
    'schema field' => 'info_id',
  );
  $info['nexteuropa_trackedchanges_info']['properties']['rel_entity_id'] = array(
    'label' => t('Entity id'),
    'description' => t('Id of entity related to the info'),
    'type' => 'integer',
    'schema field' => 'rel_entity_id',
    'getter callback' => 'nexteuropa_trackedchanges_get_entity_urls',
    'getter callback' => 'entity_property_verbatim_get',
    'setter callback' => 'entity_property_verbatim_set',
  );
  $info['nexteuropa_trackedchanges_info']['properties']['rel_entity_type'] = array(
    'label' => t('Entity type'),
    'description' => t('Type of entity related to the info'),
    'type' => 'text',
    'schema field' => 'rel_entity_type',
    'getter callback' => 'entity_property_verbatim_get',
    'setter callback' => 'entity_property_verbatim_set',
  );
  $info['nexteuropa_trackedchanges_info']['properties']['rel_entity_bundle'] = array(
    'label' => t('Entity Bundle'),
    'description' => t('Bundle of entity related to the info'),
    'type' => 'text',
    'schema field' => 'rel_entity_bundle',
    'getter callback' => 'entity_property_verbatim_get',
    'setter callback' => 'entity_property_verbatim_set',
  );
  $info['nexteuropa_trackedchanges_info']['properties']['rel_entity_label'] = array(
    'label' => t('Entity label'),
    'description' => t('Label of entity related to the info'),
    'type' => 'text',
    'schema field' => 'rel_entity_label',
    'getter callback' => 'entity_property_verbatim_get',
    'setter callback' => 'entity_property_verbatim_set',
  );
  $info['nexteuropa_trackedchanges_info']['properties']['rel_entity_languages'] = array(
    'label' => t('Entity concerned languages'),
    'description' => t('Language codes of translations containing tracked changes'),
    'type' => 'list',
    'schema field' => 'rel_entity_languages',
    'getter callback' => 'entity_property_verbatim_get',
    'setter callback' => 'entity_property_verbatim_set',
  );
  $info['nexteuropa_trackedchanges_info']['properties']['rel_entity_state'] = array(
    'label' => t('Entity moderation state'),
    'description' => t('Moderation state of entity related to the info'),
    'type' => 'text',
    'schema field' => 'rel_entity_state',
    'getter callback' => 'entity_property_verbatim_get',
    'setter callback' => 'entity_property_verbatim_set',
  );
  $info['nexteuropa_trackedchanges_info']['properties']['scanned'] = array(
    'label' => t('Scanning date of the info'),
    'description' => t('Timestamp of the date when the info entity has been created.'),
    'type' => 'date',
    'schema field' => 'scanned',
  );
}

/**
 * Get the 'nexteuropa_trackedchanges_info' entities related to an entity.
 *
 * @param string $entity_type
 *   The type of the related entity.
 * @param object $entity
 *   The related entity.
 *
 * @return bool|array
 *   An array of nexteuropa_trackedchanges_info objects indexed by their ids.
 *   When no results are found, FALSE is returned.
 *
 * @throws EntityMalformedException
 *   The exception is thrown if $entity is malformed or if $entity_type
 *   is empty.
 */
function nexteuropa_trackedchanges_info_load_by_entity($entity_type, $entity) {
  if (!$entity_type) {
    throw new EntityMalformedException('No entity type are set for this entity, 
     the "nexteuropa_trackedchanges_info" cannot be retrieved.');
  }
  if (is_object($entity)) {
    list($entity_id, , $bundle) = entity_extract_ids($entity_type, $entity);

    if (!$entity_id) {
      throw new EntityMalformedException('The entity has no id, the 
        "nexteuropa_trackedchanges_info" cannot be retrieved.');
    }

    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'nexteuropa_trackedchanges_info');
    $query->propertyCondition('rel_entity_id', $entity_id);
    if ($bundle) {
      $query->propertyCondition('rel_entity_bundle', $bundle);
    }
    $query->propertyCondition('rel_entity_type', $entity_type);
    $results = $query->execute();

    if (isset($results['nexteuropa_trackedchanges_info'])) {
      $info_ids = array_keys($results['nexteuropa_trackedchanges_info']);
      $info_entities = entity_load('nexteuropa_trackedchanges_info', $info_ids);

      if ($info_entities) {
        return $info_entities;
      }
    }

  }
  else {
    throw new EntityMalformedException('The entity passed in paramter is not 
      an object, the "nexteuropa_trackedchanges_info" cannot be retrieved.');
  }

  return FALSE;
}

/**
 * Entity property info getter callback for the entity_urls property.
 */
function nexteuropa_trackedchanges_get_entity_urls($item) {
  $entity = entity_load($item->entity_type, array($item->entity_id));
  if ($entity) {
    $uri = entity_uri($item->entity_type, $entity);

    if ($uri) {
      $lanquage_list = language_list();
      $path = $uri['path'];
      $urls = array(
        $entity->language => url($path, $lanquage_list[$entity->language]),
      );
      if (!empty($item->languages)) {
        foreach ($item->languages as $language) {
          $i18n_url = url($path, $lanquage_list[$language]);
          if ($i18n_url) {
            // TODO filtered on languages having tracked changes.
            $urls[$language] = $i18n_url;
          }
        }
      }
      return $urls;
    }
  }

  return NULL;
}

/**
 * Access callback.
 *
 * It determines if users can access the list of entities
 * with tracking changes.
 *
 * @return bool
 *    It returns true if the user has the following permissions:
 *    - ckeditor_lite highlight changes (CKEditor LITE)
 *    - administer nodes (Node)
 */
function nexteuropa_trackedchanges_info_access() {
  return (user_access('ckeditor_lite highlight changes') && user_access('administer nodes'));
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function nexteuropa_trackedchanges_form_workbench_moderation_moderate_form_alter(&$form, &$form_state, $form_id) {
  $entity = $form['node']['#value'];
  $tracking_settings = _nexteuropa_trackedchanges_wysiwyg_tracking_settings($entity);
  if ($tracking_settings['is_activate']) {
    $form['#validate'][] = '_nexteuropa_trackedchanges_tracking_wbm_validate';
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function nexteuropa_trackedchanges_form_system_modules_alter(&$form, &$form_state, $form_id) {
  $form['#validate'][] = '_nexteuropa_trackedchanges_system_disable_check_validate';
  $form['#submit'][] = '_nexteuropa_trackedchanges_system_disable_check_submit';
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function nexteuropa_trackedchanges_form_feature_set_admin_form_alter(&$form, &$form_state, $form_id) {
  $form['#validate'][] = '_nexteuropa_trackedchanges_disable_check_validate';
  $form['#submit'][] = '_nexteuropa_trackedchanges_disable_check_submit';
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Put in place the mechanism bypassing the disabling process of Feature set
 * module to replace it by specific one starting with a tracked changes scan.
 */
function nexteuropa_trackedchanges_form_feature_set_disable_url_alter(&$form, &$form_state, $form_id) {
  if ($form['featureset']['#value'] == 'nexteuropa_trackedchanges') {
    $form['nexteuropa_trackedchanges_disabling'] = array(
      '#type' => 'value',
      '#value' => TRUE,
    );
    $feature_set_submit_key = array_search('feature_set_disable_url_submit', $form['#submit']);
    $form['#submit'][$feature_set_submit_key] = '_nexteuropa_trackedchanges_disable_check_submit';
  }
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 *
 * It implements it for "Text area" widget.
 */
function nexteuropa_trackedchanges_field_widget_text_textarea_form_alter(&$element, &$form_state, $context) {
  _nexteuropa_trackedchanges_field_widget_tracking_form_alter($element, $form_state, $context);
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 *
 * It implements it for "Text area with a summary" widget.
 */
function nexteuropa_trackedchanges_field_widget_text_textarea_with_summary_form_alter(&$element, &$form_state, $context) {
  _nexteuropa_trackedchanges_field_widget_tracking_form_alter($element, $form_state, $context);
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 *
 * It implements it for "Text field" widget.
 */
function nexteuropa_trackedchanges_field_widget_text_textfield_form_alter(&$element, &$form_state, $context) {
  _nexteuropa_trackedchanges_field_widget_tracking_form_alter($element, $form_state, $context);
}

/**
 * Implements hook_field_attach_form().
 */
function nexteuropa_trackedchanges_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  // Only node entities are supported.
  $tracking_settings = _nexteuropa_trackedchanges_wysiwyg_tracking_settings($entity);
  if (($entity_type == 'node') && $tracking_settings['is_activate']) {
    if (!isset($form['language'])) {
      // The form item containing the entity can change from an entity to
      // another. Then we set it like that to easy future treatment.
      $form['language'] = array(
        '#type' => 'value',
        '#value' => $langcode,
      );
    }
    $form['#validate'][] = '_nexteuropa_trackedchanges_tracking_entity_validate';
    $form['actions']['submit']['#submit'][] = '_nexteuropa_trackedchanges_tracking_entity_log';
  }
}

/**
 * Implements hook_entity_view_alter().
 */
function nexteuropa_trackedchanges_entity_view_alter(&$build, $type) {
  _nexteuropa_trackedchanges_ckeditor_lite_view_alter($build, $type);
}

/**
 * Implements hook_tmgmt_dgt_html_filter_formats_containing_html().
 */
function nexteuropa_trackedchanges_tmgmt_dgt_html_filter_formats_containing_html() {
  return array(
    'full_html_track',
  );
}

/**
 * Implements hook_wysiwyg_editor_settings_alter().
 *
 * Alter the display and the status (active/inactive) of CKEditor LITE buttons.
 */
function nexteuropa_trackedchanges_wysiwyg_editor_settings_alter(&$settings, $context) {
  $state = multisite_wysiwyg_set_current_entity_object_state();

  if ($context['profile']->editor == 'ckeditor') {
    // If ckeditor_lite_istracking is not set, the default value is 1.
    // For feature needs, the logic is inverted.
    $settings['lite']['isTracking'] = variable_get('ckeditor_lite_istracking') ? TRUE : FALSE;
  }

  if ($state == 'create') {
    $is_btn_disabled = variable_get('nexteuropa_trackedchanges_disable_track_on_create');
    if ($is_btn_disabled) {
      // Turn CKEditor Lite tracking off by default.
      $extra_plugins = explode(',', $settings['extraPlugins']);
      foreach ($extra_plugins as $key => $plugin) {
        if ($plugin == 'lite') {
          unset($extra_plugins[$key]);
        }
      }
      $settings['extraPlugins'] = implode(',', $extra_plugins);
    }
  }
  elseif ($state == 'edit') {
    // Force the enabling of CKEditor Lite change tracking on edit
    // entity pages.
    $force_btn_enabled = variable_get('nexteuropa_trackedchanges_force_track_on_edit');
    if ($force_btn_enabled) {
      $settings['lite']['isTracking'] = TRUE;
    }
  }
}

/**
 * Add all buttons related to CKEditor Lite in the WYSIWYG profile.
 *
 * @param string $profile_name
 *   The machine name of the profile's text format.
 */
function _nexteuropa_trackedchanges_enable_buttons($profile_name) {
  $lite_plugin_settings = array(
    'lite_AcceptAll',
    'lite_RejectAll',
    'lite_AcceptOne',
    'lite_RejectOne',
    'lite_ToggleShow',
    'lite_ToggleTracking',
  );
  multisite_config_service('wysiwyg')->addButtonsToProfile(
    $profile_name,
    'lite',
    $lite_plugin_settings
  );
}


/**
 * Remove all buttons related to CKEditor Lite in the WYSIWYG profile.
 *
 * That has the same effect as delting 'lite' settings from the profile.
 *
 * @param string $profile_name
 *   The machine name of the profile's text format.
 */
function _nexteuropa_trackedchanges_disable_buttons($profile_name) {
  $profile = multisite_config_service('wysiwyg')->getProfile($profile_name);

  if (isset($profile->settings['buttons']['lite'])) {
    unset($profile->settings['buttons']['lite']);
  }

  multisite_config_service('wysiwyg')->updateProfile($profile);
}

/**
 * Helper function for fetching WYSIWYG profiles.
 *
 * @return array
 *    An array with WYSIWYG profiles.
 */
function _nexteuropa_trackedchanges_get_profiles() {
  $wysiwyg_profiles = [];
  $formats = filter_formats();

  // Only list profiles that have a WYSIWYG editor associated with.
  $profiles = wysiwyg_profile_load_all();
  $profiles = array_filter($profiles, function ($profile) {
    return !empty($profile->editor);
  });

  // Generating array with options array and change tracking status.
  foreach ($profiles as $key => $profile) {
    $wysiwyg_profiles['options'][$key] = $formats[$key]->name;
    $wysiwyg_profiles['info'][$key]['name'] = $formats[$key]->name;
    if (isset($profile->settings['buttons']['lite']) && count($profile->settings['buttons']['lite'])) {
      $wysiwyg_profiles['info'][$key]['cke_lite_status'] = TRUE;
    }
    else {
      $wysiwyg_profiles['info'][$key]['cke_lite_status'] = FALSE;
    }
  }

  // Removing profile which by default needs to have change tracking enabled.
  if (isset($wysiwyg_profiles['options'][NEXTEUROPA_TRACKEDCHANGES_FHT_MACHINE_NAME])) {
    unset($wysiwyg_profiles['options'][NEXTEUROPA_TRACKEDCHANGES_FHT_MACHINE_NAME]);
  }
  return $wysiwyg_profiles;
}

/**
 * Scan the field revision table for traccked changes.
 *
 * @param string $field_name
 *   The field machine name of the table to scan.
 * @param string $text_format
 *   The text format machine name on which the scan must focus.
 *
 * @return array|bool
 *   Array listing entity types and bundle for which tracked changes have
 *   been detected.
 */
function _nexteuropa_trackedchanges_check_field_revisions($field_name, $text_format = '') {
  // 2. Scan field revision table to see if tracked changes tag are present.
  // Because of Workbench moderation, field data table could not contain any
  // tags for node values while the draft revision (contained in the revision
  // tables could have.
  $query = db_select('field_revision_' . $field_name, 'fr');
  $query->where('fr.' . $field_name . '_value REGEXP \'<span[^>]+class="[^"]*ice-[^>]+>\'')
    ->condition('fr.deleted', 0);
  if ($text_format) {
    $query->condition('fr.' . $field_name . '_format', $text_format);
  }
  $query->fields('fr', array('entity_type', 'bundle'));
  $query->distinct(TRUE);

  $results = $query->execute()->fetchAll();

  if ($results) {
    $return = array();
    foreach ($results as $result) {
      $key = $field_name . '-' . $result->entity_type . '-' . $result->bundle;
      $result->field_name = $field_name;
      $return[$key] = $result;
    }

    return $return;
  }

  return FALSE;
}

/**
 * Get entities that have tracked changes in values for a specific field.
 *
 * @param string $field_name
 *    The field machine name to scan.
 * @param string $entity_type
 *    The type of entities to scan.
 * @param string $bundle
 *    The bundle of entities to scan.
 * @param string $text_format
 *   The text_format on which the scanning process needs to focus.
 *   If set, the process scans only values using this text format.
 *
 * @return array|bool
 *   Array of NextEuropaTrackedChangesInfo equivalent arrays;
 *   FALSE if not tracked changes have been detected.
 */
function _nexteuropa_trackedchanges_check_field_entities($field_name, $entity_type = 'node', $bundle = 'page', $text_format = '') {
  $return = array();

  switch ($entity_type) {
    case 'node':
      // 3.a.1 Check if workbench moderation is active for the node.
      // Check content published and "draft" versions.
      if (module_exists('workbench_moderation')) {
        if (workbench_moderation_node_type_moderated($bundle)) {
          $query = db_select('field_revision_' . $field_name, 'fr');
          $query->join('node', 'n', 'fr.entity_id = n.nid');
          $query->join('workbench_moderation_node_history', 'wmhn', 'fr.revision_id = wmhn.vid');
          $query->where('fr.' . $field_name . '_value REGEXP \'<span[^>]+class="[^"]*ice-[^>]+>\'')
            ->condition('wmhn.is_current', 1)
            ->condition('fr.bundle', $bundle);
          if ($text_format) {
            $query->condition('fr.' . $field_name . '_format', $text_format);
          }
          $query->fields('fr', array('language'))
            ->fields('n', array('nid'))
            ->fields('wmhn', array('state'));
          $query->addField('fr', $field_name . '_format', 'format');
          $query->distinct(TRUE);
          $node_scans = $query->execute()->fetchAllAssoc('nid');

          foreach ($node_scans as $node_scan) {
            $info = array(
              'entity_type' => $entity_type,
              'bundle' => $bundle,
              'entity_id' => $node_scan->nid,
              'state' => $node_scan->state,
              'languages' => array($node_scan->language),
            );

            $return[] = $info;
          }
        }

        // Code executed below is useless as already checked here.
        // Then, break.
        break;
      }

      // 3.a.2 Check other nodes on the field data table which is the current
      // version to take into account.
      $query = db_select('field_data_' . $field_name, 'fd');
      $query->join('node', 'n', 'fd.entity_id = n.nid');
      $query->condition('fr.bundle', $bundle)
        ->where('fd.' . $field_name . '_value REGEXP \'<span[^>]+class="[^"]*ice-[^>]+>\'');
      if ($text_format) {
        $query->condition('fd.' . $field_name . '_format', $text_format);
      }
      $query->fields('fd', array('language'))
        ->fields('n', array('nid'));
      $query->distinct(TRUE);
      $node_scans = $query->execute()->fetchAllAssoc('nid');

      foreach ($node_scans as $node_scan) {
        $info = array(
          'entity_type' => $entity_type,
          'bundle' => $bundle,
          'entity_id' => $node_scan->nid,
          'state' => FALSE,
          'languages' => array($node_scan->language),
        );

        $return[] = $info;
      }
      break;

    default:
      // 3.b. Get info on related entities.
      $query = db_select('field_data_' . $field_name, 'fd');
      $query->condition('fd.bundle', $bundle)
        ->where('fd.' . $field_name . '_value REGEXP \'<span[^>]+class="[^"]*ice-[^>]+>\'');
      if ($text_format) {
        $query->condition('fd.' . $field_name . '_format', $text_format);
      }
      $query->fields('fd', array('entity_id', 'language'));
      $query->distinct(TRUE);
      $node_scans = $query->execute()->fetchAllAssoc('entity_id');

      foreach ($node_scans as $entity_scan) {
        $info = array(
          'entity_type' => $entity_type,
          'bundle' => $bundle,
          'entity_id' => $entity_scan->entity_id,
          'state' => FALSE,
          'languages' => array($entity_scan->language),
        );

        $return[] = $info;
      }
      break;
  }

  return $return;
}

/**
 * Get entities that have  tracked changes in values for a specific field.
 *
 * @param string $field_name
 *    The field machine name to scan.
 * @param string $text_format
 *   The text_format on which the scanning process needs to focus.
 *   If set, the process scans only values using this text format.
 *
 * @return array|bool
 *   Array of entities data where tracked changes have been detected for the
 *   scanned field; FALSE if not tracked changes have been detected.
 *   For each retrived entity, the following data are supplied:
 *   - string entity_type: Entity type (node, traxonomy term, etc.);
 *   - string bundle: the bundle of the entity;
 *   - int entity_id: entity id;
 *   - string language: entity language code;
 *   - string|bool state: Workbench moderation state; FALSE if not applicable.
 */
function _nexteuropa_trackedchanges_check_field_values($field_name, $text_format = '') {
  // 2. Scan field revision table to see if tracked changes tag are present.
  // Because of Workbench moderation, field data table could not contain any
  // tags for node values while the draft revision (contained in the revision
  // tables could have.
  $query_results = _nexteuropa_trackedchanges_check_field_revisions($field_name, $text_format);

  if (!$query_results) {
    return FALSE;
  }

  $return = array();
  foreach ($query_results as $query_result) {
    $entity_type = $query_result->entity_type;
    $bundle = $query_result->bundle;

    switch ($entity_type) {
      case 'node':
        // 3.a.1 Check if workbench moderation is active for the node.
        // Check content published and "draft" versions.
        if (module_exists('workbench_moderation')) {
          if (workbench_moderation_node_type_moderated($bundle)) {
            $db_or_state = db_or()->condition('wmhn.is_current', 1)->condition('wmhn.published', 1);
            $query = db_select('field_revision_' . $field_name, 'fr');
            $query->join('node', 'n', 'fr.entity_id = n.nid');
            $query->join('workbench_moderation_node_history', 'wmhn', 'fr.revision_id = wmhn.vid');
            $query->where('fr.' . $field_name . '_value REGEXP \'<span[^>]+class="[^"]*ice-[^>]+>\'')
                  ->condition($db_or_state)
                  ->condition('fr.bundle', $bundle);
            if ($text_format) {
              $query->condition('fr.' . $field_name . '_format', $text_format);
            }
            $query->fields('fr', array('language'))
                  ->fields('n', array('nid'))
                  ->fields('wmhn', array('state'));
            $query->addField('fr', $field_name . '_format', 'format');
            $query->distinct(TRUE);
            $node_scans = $query->execute()->fetchAllAssoc('nid');

            foreach ($node_scans as $node_scan) {
              $return[] = array(
                'entity_type' => $entity_type,
                'bundle' => $bundle,
                'entity_id' => $node_scan->nid,
                'language' => $node_scan->language,
                'state' => $node_scan->state,
              );
            }
          }

          // Code executed below is useless as already checked here.
          // Then, break.
          break;
        }

        // 3.a.2 Check other nodes on the field data table which is the current
        // version to take into account.
        $query = db_select('field_data_' . $field_name, 'fd');
        $query->join('node', 'n', 'fd.entity_id = n.nid');
        $query->condition('fr.bundle', $bundle)
              ->where('fd.' . $field_name . '_value REGEXP \'<span[^>]+class="[^"]*ice-[^>]+>\'');
        if ($text_format) {
          $query->condition('fd.' . $field_name . '_format', $text_format);
        }
        $query->fields('fd', array('language'))
              ->fields('n', array('nid'));
        $query->distinct(TRUE);
        $node_scans = $query->execute()->fetchAllAssoc('nid');

        foreach ($node_scans as $node_scan) {
          $return[] = array(
            'entity_type' => $entity_type,
            'bundle' => $bundle,
            'entity_id' => $node_scan->nid,
            'language' => $node_scan->language,
            'state' => FALSE,
          );
        }
        break;

      default:
        // 3.b. Get info on related entities.
        $query = db_select('field_data_' . $field_name, 'fd');
        $query->condition('fd.bundle', $bundle)
              ->where('fd.' . $field_name . '_value REGEXP \'<span[^>]+class="[^"]*ice-[^>]+>\'');
        if ($text_format) {
          $query->condition('fd.' . $field_name . '_format', $text_format);
        }
        $query->fields('fd', array('entity_id', 'language'));
        $query->distinct(TRUE);
        $node_scans = $query->execute()->fetchAllAssoc('entity_id');

        foreach ($node_scans as $entity_scan) {
          $return[] = array(
            'entity_type' => $entity_type,
            'bundle' => $bundle,
            'entity_id' => $entity_scan->entity_id,
            'language' => $entity_scan->language,
            'state' => FALSE,
          );
        }
        break;
    }
  }

  return $return;
}

/**
 * Get machine name of potential WYSIWYG fields.
 *
 * These fields are of the following types: text_long, text, text_with_summary.
 *
 * @return array
 *    list of field machine names.
 *
 * @see field_info_field_map
 */
function _nexteuropa_trackedchanges_wysiwyg_fields_info() {
  $field_types = array(
    'text_long',
    'text_with_summary',
    'text',
  );
  $field_info_map = field_info_field_map();
  $filtered = array_filter($field_info_map, function ($item) use ($field_types) {
    return in_array($item['type'], $field_types);
  });

  return array_keys($filtered);
}

/**
 * Batch operation callback scanning field revision tables for tracked changes.
 */
function _nexteuropa_trackedchanges_revisions_scanning_process(&$context) {
  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 0;
    $context['results']['detected_entity_types'] = array();
    $context['sandbox']['field_list'] = _nexteuropa_trackedchanges_wysiwyg_fields_info();
    $context['sandbox']['max'] = count($context['sandbox']['field_list']);
  }

  $field_name = array_shift($context['sandbox']['field_list']);
  $context['message'] = t("@field_name's revision table is scanned", array('@field_name' => $field_name));

  $scanning_results = _nexteuropa_trackedchanges_check_field_revisions($field_name);

  if ($scanning_results) {
    $previous_detected_items = $context['results']['detected_entity_types'];
    $results = array_merge($previous_detected_items, $scanning_results);
    $context['results']['detected_entity_types'] = $results;
  }
  $context['sandbox']['progress']++;

  if (empty($context['sandbox']['field_list'])) {
    $context['finished'] = 1;
  }
  elseif ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Batch operation scanning field revision tables for tracked changes.
 *
 * @see nexteuropa_trackedchanges_table_rebuilt()
 */
function _nexteuropa_trackedchanges_entity_scanning_process(&$context) {
  if (!isset($context['sandbox']['detected_entity_types'])) {
    $context['sandbox']['progress'] = 0;
    $context['results']['detected_entities'] = array();
    $context['sandbox']['detected_entity_types'] = $context['results']['detected_entity_types'];
    $context['sandbox']['max'] = count($context['sandbox']['detected_entity_types']);
  }

  $message['message'] = t('No scan to perform on entities.');
  if (!empty($context['sandbox']['detected_entity_types'])) {
    $field_entity_info = array_shift($context['sandbox']['detected_entity_types']);
    $context['message'] = t("@field_name's entities are scanned", array('@field_name' => $field_entity_info->field_name));

    $scanning_results = _nexteuropa_trackedchanges_check_field_entities($field_entity_info->field_name, $field_entity_info->entity_type, $field_entity_info->bundle);

    if ($scanning_results) {
      $previous_detected_items = $context['results']['detected_entities'];
      foreach ($scanning_results as $scanning_result) {
        $key = $scanning_result['entity_type'] . '-' . $scanning_result['bundle'] . '-' . $scanning_result['entity_id'];
        if (isset($previous_detected_items[$key])) {
          // From _nexteuropa_trackedchanges_check_field_entities, we know there
          // is only one language in the "languages" array.
          $scanned_language = end($scanning_result['languages']);
          if (!in_array($scanned_language, $previous_detected_items[$key]['languages'])) {
            $previous_detected_items[$key]['languages'][] = $scanned_language;
          }
        }
        else {
          $previous_detected_items[$key] = $scanning_result;
        }
      }
      $context['results']['detected_entities'] = $previous_detected_items;
    }
  }
  $context['sandbox']['progress']++;

  if (empty($context['sandbox']['detected_entity_types'])) {
    $context['finished'] = 1;
  }
  elseif ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}
