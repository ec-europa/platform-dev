<?php

/**
 * @file
 * Module file of the translation management Poetry .
 */

/**
 * Implements hook_tmgmt_translator_plugin_info().
 */
function tmgmt_poetry_tmgmt_translator_plugin_info() {
  return array(
    'poetry' => array(
      'label' => t('Poetry translator'),
      'description' => t('Poetry Translator service.'),
      'plugin controller class' => 'TMGMTPoetryTranslatorPluginController',
      'ui controller class' => 'TMGMTPoetryTranslatorUIController',
    ),
  );
}

/**
 * Local Exception class
 */
class TMGMTPoetryException extends Exception {
  /**
   * Override of the parent __construct method.
   */
  public function __construct($message = "", $data = array(), $code = 0, Exception $previous = NULL) {
    parent::__construct(strtr($message, $data), $code, $previous);
  }
}

/**
 * Implements hook_menu().
 */
function tmgmt_poetry_menu() {
  $items = array();
  $items['tmgmt_poetry/service_callback'] = array(
    'page callback' => '_tmgmt_poetry_service_callback',
    'access callback' => TRUE,
  );
  return $items;
}

/**
 * Function to define our webservice and register the available methods.
 */
function _tmgmt_poetry_service_callback() {
  // Generate our own SOAP server.
  $server = new SoapServer(drupal_get_path("module", "tmgmt_poetry") . "/wsdl/PoetryIntegration.wsdl");
  $server->AddFunction("FPFISPoetryIntegrationRequest");
  $server->handle();

}

/**
 * Function available to call from our webservice.
 */
function FPFISPoetryIntegrationRequest($user, $password, $msg) {

  // Authenticate the request.
  if (_tmgmt_poetry_authenticate($user, $password)) {
    watchdog("POETRY", "Poetry callback authenticated correctly.");
    // Load the received XML and load the referenced Job.
    $xml = simplexml_load_string($msg);
    $request = $xml->request;
    $reference = implode("/", (array) $request->demandeId);
    $job = _tmgmt_poetry_load_job_by_reference($reference);
    // If the received message has a status, record it in the job.
    if (isset($request->status)) {
      foreach ($request->status as $status) {
        if (isset($status->statusMessage)) {
          $message[] = $status->statusMessage;
        }
      }
      $message = implode(", ", $message);
      $job->addMessage('Poetry message received: @message', array('@message' => $message));
    }
    // If the received message has the translated file, add it to the job.
    if (isset($request->attributions->attributionsFile)) {
      $content = (string) $request->attributions->attributionsFile;
      // Create a temporal file to store the received content.
      $temp_filepath = (string) variable_get('file_private_path') . "/" .  $job->tjid . ".html";
      $temp_file = fopen($temp_filepath, "w");
      fwrite($temp_file, base64_decode($content));
      fclose($temp_file);
      // Load controler to import the received file.
      $controller = tmgmt_file_format_controller($job->getSetting('export_format'));
      if ($controller) {
        // Validate the file.
        $validated_job = $controller->validateImport($temp_filepath);
        if (!$validated_job) {
          $job->addMessage('Failed to validate file, import aborted.', array(), 'error');
        }
        elseif ($validated_job->tjid != $job->tjid) {
          $uri = $validated_job->uri();
          $label = $validated_job->label();
          $job->addMessage('Import file is from job <a href="@url">@label</a>, import aborted.', array('@url' => url($uri['path']), '@label' => $label));
        }
        else {
          try {
            // Validation successful, start import.
            $job->addTranslatedData($controller->import($temp_filepath));
            $job->addMessage('Successfully received the translation file.');
          }
          catch (Exception $e) {
            $job->addMessage('File import failed with the following message: @message', array('@message' => $e->getMessage()), 'error');
          }
        }
      }
      // Delete temporal file.
      $realpath = realpath($temp_filepath);
      if (is_readable($realpath)) {
        unlink($realpath);
      }
    }
    // Send answer to poetry.
    $xml = _tmgmt_poetry_generate_answer_xml($job, 'OK');
    return $xml->asXML();
  }
  else {
    watchdog("POETRY", "Poetry callback failed authentication.", WATCHDOG_WARNING);
    // Send answer to poetry.
    $xml = _tmgmt_poetry_generate_answer_xml($job, 'ERROR: Failed authentication.');
    return $xml->asXML();
  }
}

/**
 * Helper function to create the XML to send to Poetry.
 */
function _tmgmt_poetry_generate_request_xml($job) {

  // Load translator settings.
  $translator = $job->getTranslator();
  // Load data exporter.
  $controller = tmgmt_file_format_controller($job->getSetting('export_format'));

  // Encode the data to be translated.
  $content = base64_encode($controller->export($job));

  // Generate the ID for the request.
  $id_data = array(
    'codeDemandeur' => 'DIGIT',
    'annee' => date("Y"),
    'sequence' => 'DIGIT',
    'version' => 00,
    'partie' => 00,
    'produit' => 'TRA',
  );

  // Generate the callback parameters.
  global $base_url;
  $poetry = variable_get("poetry_service");
  $callback_username = $poetry['callback_user'];
  $callback_password = $poetry['callback_password'];
  $callback_address = $base_url . '/tmgmt_poetry/service_callback?wsdl';
  $callback_path = 'FPFISPoetryIntegrationRequest';
  $callback_remark = '';

  // Create initial XML element using POETRY headers.
  $xml = new SimpleXMLElement("<?xml version=\"1.0\" encoding=\"utf-8\" ?>
    <POETRY xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" 
    xsi:noNamespaceSchemaLocation=\"http://intragate.ec.europa.eu/DGT/poetry_services/poetry.xsd\">
    </POETRY>");

  // Add main request element.
  $request = $xml->addChild('request');
  $request->addAttribute('communication', 'asynchrone');
  $request->addAttribute('id', implode("/", $id_data));
  $request->addAttribute('type', 'newPost');

  // Add the ID to the request.
  $application_id = $request->addChild('demandeID');
  foreach ($id_data as $key => $value) {
    $application_id->addChild($key, $value);
  }

  // Add request information.
  $application = $request->addChild('demande');
  $application->addChild('userReference', $job->tjid);
  $application->addChild('titre', $job->label);
  $application->addChild('organisationResponsable', 'DIGIT');
  $application->addChild('organisationAuteur', 'IE/CE/DIGIT');
  $application->addChild('serviceDemandeur', 'IE/CE/DIGIT/A/3');
  $application->addChild('applicationReference', 'FPFIS');
  $application->addChild('delai', date('d/m/Y', strtotime('+1 year')));

  $procedure = $application->addChild('procedure');
  $procedure->addAttribute('id', 'NEANT');

  $destination = $application->addChild('destination');
  $destination->addAttribute('id', 'PUBLIC');

  $type = $application->addChild('type');
  $type->addAttribute('id', 'INF');

  // Get contact information from translator and add it to the request.
  $contacts = $translator->getSetting('contacts');

  $author = $request->addChild('contacts');
  $author->addAttribute('type', 'auteur');
  $author->addChild('contactNickname', $contacts['author']);

  $secretary = $request->addChild('contacts');
  $secretary->addAttribute('type', 'secretaire');
  $secretary->addChild('contactNickname', $contacts['secretary']);

  $contact = $request->addChild('contacts');
  $contact->addAttribute('type', 'contact');
  $contact->addChild('contactNickname', $contacts['contact']);

  $responsible = $request->addChild('contacts');
  $responsible->addAttribute('type', 'responsable');
  $responsible->addChild('contactNickname', $contacts['responsible']);

  // Add callback information to the request.
  $callback = $request->addChild('retour');
  $callback->addAttribute('type', 'webService');
  $callback->addAttribute('action', 'UPDATE');
  $callback->addChild('retourUser', $callback_username);
  $callback->addChild('retourPassword', $callback_password);
  $callback->addChild('retourAddress', $callback_address);
  $callback->addChild('retourPath', $callback_path);
  $callback->addChild('retourRemark', $callback_remark);

  // Add the content to be translated.
  $filename = 'content.html';
  $document_source = $request->addChild('documentSource');
  $document_source->addAttribute('format', 'HTML');
  $document_source->addChild('documentSourceName', $filename);
  $language = $document_source->addChild('documentSourceLang');
  $language->addAttribute('lgCode', strtoupper($job->source_language));
  $language->addChild('documentSourceLangPages', '1');
  $document_source->addChild('documentSourceFile', $content);

  $attribution = $request->addChild('attributions');
  $attribution->addAttribute('format', 'HTML');
  $attribution->addAttribute('lgCode', strtoupper($job->target_language));

  $attribtion_delay = $attribution->addChild('attributionsDelai', date('d/m/Y', strtotime('+1 year')));
  $attribtion_delay->addAttribute('format', 'DD/MM/YYYY');

  return $xml;
}

/**
 * Helper function to generate an answer xml for received Poetry requests.
 */
function _tmgmt_poetry_generate_answer_xml($job, $message) {

  // Create initial XML element using POETRY headers.
  $xml = new SimpleXMLElement("<?xml version=\"1.0\" encoding=\"utf-8\" ?>
    <POETRY xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" 
    xsi:noNamespaceSchemaLocation=\"http://intragate.ec.europa.eu/DGT/poetry_services/poetry.xsd\">
    </POETRY>");

  // Add main request element.
  $request = $xml->addChild('request');
  $request->addAttribute('id', $job->reference);
  $request->addAttribute('type', 'status');

  // Add request identifier.
  $application_id_data = explode('/', $job->reference);
  $application_id = $request->addChild('demandeID');
  $application_id->addChild('codeDemandeur', $application_id_data[0]);
  $application_id->addChild('annee', $application_id_data[1]);
  $application_id->addChild('numero', $application_id_data[2]);
  $application_id->addChild('version', $application_id_data[3]);
  $application_id->addChild('partie', $application_id_data[4]);
  $application_id->addChild('produit', $application_id_data[5]);

  $status = $request->addChild('status');
  $status->addAttribute('type', 'request');
  $status->addAttribute('code', 0);

  $status_date = $status->addChild('statusDate', date('d/m/Y'));
  $status_date->addAttribute('format', 'dd/mm/yyyy');

  $status_time = $status->addChild('statusTime', date('h:i:s'));
  $status_time->addAttribute('format', 'hh:mm:ss');

  $status->addChild('statusMessage', 'OK');

  return $xml;
}

/**
 * Helper function to authenticate request made to our service.
 */
function _tmgmt_poetry_authenticate($user, $password) {
  // Get Poetry configuration.
  $poetry = variable_get("poetry_service");
  if (($poetry['callback_user'] == $user) &&
    ($poetry['callback_password'] == $password)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper function to retrive a Job based on its reference.
 */
function _tmgmt_poetry_load_job_by_reference($reference) {
  $job = NULL;
  $result = db_select('tmgmt_job', 'job')
    ->fields('job', array('tjid'))
    ->condition('reference', $reference, '=')
    ->execute()
    ->fetchAssoc();
  if (isset($result['tjid']) && !empty($result['tjid'])) {
    $job = tmgmt_job_load($result['tjid']);
  }
  return $job;
}

/**
 * Helper function to send a soap request.
 */
function _tmgmt_poetry_send_soap_request($xml) {
  $msg = $xml->asXML();

  // Get Poetry configuration.
  $poetry = variable_get("poetry_service");

  // Create soap client.
  try {
    $client = new SoapClient($poetry['address']);
  }
  catch (Exception $e) {
    $response = 'Error new SoapClient : ' . $e->getMessage();
  }

  // Send the SOAP request and handle possible errors.
  try {
    $response = $client->$poetry['method']($poetry['user'], $poetry['password'], $msg);
  }
  catch (Exception $e) {
    $response = 'Error sending soap call : ' . $e->getMessage();
  }
  return $response;
}

/**
 * Helper module to check MT@EC settings.
 */
function _tmgmt_poetry_check_poetry_settings() {
  $messages = array();
  $poetry_settings = variable_get('poetry_service');
  if (empty($poetry_settings)) {
    $messages[] = t('Main "poetry_service" variable was not set or is empty. See the README.txt file or read the wiki page.');
    $type = 'error';
  }
  if (empty($messages)) {
    $messages[] = t('Main "poetry_service" variable is properly set.');
    $type = 'status';
  }
  return _tmgmt_poetry_theme_messages($messages, $type);
}

/**
 * Helper module to theme MT@EC messages.
 *
 * @param array $messages
 *   Array of messages to be displayed.
 * @param string $type
 *   Type of the messages.
 *
 * @return string
 *   Themed messages.
 */
function _tmgmt_poetry_theme_messages($messages, $type) {
  $output = "<div class=\"messages $type\">\n";
  $output .= theme("item_list", array("items" => $messages));
  $output .= "</div>\n";
  return $output;
}
